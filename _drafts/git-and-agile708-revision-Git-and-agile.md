---
id: 709
title: Git and agile
date: 2010-03-07T20:25:51+00:00
author: Jilles
layout: revision
guid: http://www.jillesvangurp.com/2010/03/07/708-revision/
permalink: /2010/03/07/708-revision/
---
I've been working with svn since 2004 (we used a pre  1.0 version at GX). I started hearing about git around the 2006-2007 when the Linus Torvalds replacement for Bitkeeper started maturing enough for other people to use it. I met people working on Maemo (the Debian based OS for the N770, N800, N810, and recently the N900) in Nokia who were really enthusiastic about it in 2008. They had to use it to work with all the upstream projects Maemo depends on and they loved it. When I moved to Berlin everybody there was using subversion so I just conformed and ignored git/mercurial and all those other cool versioning systems out there for an entire year. It turns out that was lost time, I should have switched around 2007/2008. I'm especially annoyed by this because I've been aware of decentralized versioning being superior to centralized versioning since then. If you don't believe me, I had a workshop paper at SPLC 2006 on version management and variability management that pointed out the emerging of DVCSes in that context. I've wasted at least three years. Ages for the early adopter I still consider myself to be.

Anyway, after weighing the pros and cons for way too long, I switched from subversion to git last week. What triggered me to do this was, oddly, an excellent <a href="http://hginit.com/00.html">tutorial on Mercurial by Joel Spolsky</a>. Nothing against Mercurial, but Git has the momentum in my view and is definitely appears to be the band wagon to be jumping right now and I don't see any big technical argument for using Mercurial instead of Git. There's <a href="http://github.com/">github</a> and no mercurial hub as far as I know. So, git it is.

My colleagues of course haven't switched (yet, mostly) but that is not an issue with git-svn, which allows me to interace with svn repositories. I'd like to say that switching was an easy ride, except it wasn't. The reason is not git but me.  Git is a powerful tool that has quite a bit more features than more simple solutions like subversion. Martin Fowler has a <a href="http://martinfowler.com/bliki/VersionControlTools.html">nice diagram on "recommendability" and "required skill"</a>. Git is in the top right corner (highly recommended but you'll need to learn some new skills). The good news is that you will need only a small subset of commands to cover the feature set provided by svn and you can gradually expand what you use from there. Even with this small subset it is probably worth the trouble. The bad news is that you will just have to sit down and spend a few hours learning the basics. I spent a bit more than I planned to on this but in the end I got there.

The mistake I made that caused me to delay the switch for years was not realizing that git adds loads of value even when your colleagues are not using it. There are two parts to my mistake. The first is that the whole point of git is branching. You don't have a working copy, you have a branch. It's exactly the same with git-svn: you don't have a working copy but a branch. So what, you might think. Well the point of git is that you don't update but merge changes to your local branch. With svn branching and merging is painful, so instead of having branches and merging between them, you avoid conflicts by updating often and committing often. 

With git, merging is effortless. With git-svn, you don't update from svn trunk, you merge its changes in your local branch. You are working on a branch by default and creating more than 1 is really not something to be scared of. It's is pain-less, even if you have a large amount of uncommitted work (which would get you in trouble with svn). Even if that work includes renaming the top level directories in your project (I did this). That's a really valuable feature to have around. It means I can work on big changes to the code without having to worry about upstream svn commits. The type of changes nobody dares to take on because it would be too disruptive to deal with branching and merging and because there are "more important things" to do so we don't want to destabilize trunk. Well, not any more. I can work on it locally  on a git branch for weeks if needed and push it back to trunk when it is ready while at the same time me and my colleagues keep committing big changes on trunk. The reason I'm so annoyed right now is the time I spent on resolving svn conflicts in the past four years was essentially unnecessary. Not switching four years ago was a big mistake.

The second part of my mistake was assuming I needed IDE support for git to be able to deal with refactoring and particularly class renames. While there is <a href="http://www.eclipse.org/egit/">egit</a> now, it is still pretty immature. It turns out that this was a false assumption. If you rename a file in a git repository and commit the file, Git will automatically figure out that the file was renamed, you don't need to tell git that the file was renamed. A simple "mv foo.java bar.java" will work. On directories too. This is a really cool feature. So I can develop in eclipse without it even being aware of any git specifics, refactor and rename as much as I like, and git will keep tracking the changes for me. Even better, certain types of refactorings that are quite tricky with subclipse and subversive just work in git. I've corrupted svn work directories on several occasions when trying to rename packages and moving stuff around. Git will handle this effortlessly. If you think about it, tracking renames automatically is essential for merges as well. Merges work so well because git can handle the situation where a locally renamed file needs changes from upstream merged into it. 

We have plenty of pending big changes and refactorings that we have been delaying because they are disruptive. Git allows me to work on these changes whenever I feel like it without having to finish them before somebody else starts introducing conflicting changes. This is not just a technical advantage, it's a process advantage. Subversion forces you to serialize change so that you minimize the interactions. That's another way of saying that subversion is all about waterfall. Git allows you to decouple change instead and parallelize the work more effectively. Secondly, subversion is causing us to delay necessary changes, i.e. changes that we would prefer to do if only it wouldn't be so disruptive. Delayed changes pile up to become technical debt. Think of git as a tool to manage your technical debt. You can work on business value adding changes (and keep the managers happy) and disruptive changes at the same time without the two interfering. In other words you can be more agile. Agile has always been about technical enablers (refactoring tooling, unit testing frameworks, continuous integration infrastructure, version control, etc) as much as it was about process. Having the infrastructure to do rapid iterations and release frequently is critical to the ability to release every sprint. You can't do one without the other. Decentralized version management is another essential tool in this context. 

But as I said, switching from svn to git wasn't a smooth ride. Getting familiar with the various git commands and how they are different from what I am used to in svn has been taking some time despite the fact that I understand how it works and how I am supposed to use it. I'm a git newby and I've been making lots of beginners mistakes (mainly using the wrong git commands for the things I was trying to do). The good news is that I managed to get some pretty big changes committed back to the central svn repository without losing any work (which is the point of version management). The bad news is that I got stuck several times trying to figure out how to rebase properly, how to undo certain changes, how to recover a messed up checkout on top of my local work directory from the local git repository. In short, I learned a lot on this and I have still some more things to learn. On the other hand, I can track changes from svn trunk, have local topic branches, merge from those to the local git master, and dcommit back to trunk. That about covers all my basic needs.